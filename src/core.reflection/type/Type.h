/**
 * Copyright (C) 2013 Tobias P. Becker
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software
 * and associated documentation files (the "Software"), to deal in the Software without restriction,
 * including without limitation the  rights to use, copy, modify, merge, publish, distribute,
 * sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 */
#pragma once
#include <config.h>
#include <core.graph/Node.h>
#include <core.collection/containers/Set.h>
#include <core.property/Members.h>
#include <core.properties.h>
#include <memory>
namespace nspace
{
  // forward declarations
  class MemberInfo;
  class MethodInfo;
  class PropertyInfo;
  class Type;
  class Object;
  /**
   * \brief Defines an alias representing identifier for a type.
   */
  typedef uint TypeId;


  /**
   * \brief Type.
   *        this class represents a Type. it Inherits from Node<Type> so that a the typehierarcy may be accessed.
   *        Alot of Macros are defined to help specify types / members for classes
   *        This class contains methods for reflecting over Objects
   */
  class Type : public Node<Type>
  {
private:

    /**
     * \brief The type counter. - every type has a unique int associated with it which is generated by incrementing this counter at every type registration
     */
    static TypeId _typeCounter;
protected:

    /**
     * \brief Default constructor.
     *        Registers the type.
     */
    Type();
public:

    /**
     * \brief Equality operator.
     * \return  true if the types are considered equivalent.
     */
    friend bool operator==(const Type & a, const Type & b);

    /**
     * \brief Inequality operator.
     * \return  true if the types are not considered equivalent.
     */
    friend inline bool operator!=(const Type & a, const Type & b) {
      return !(a==b);
    }

    /**
     * \brief Stream insertion operator.
     *        Prints  a "pretty" representation of the type into the stream
     * 
     */
    friend std::ostream & operator <<(std::ostream & out, const Type & type);

    /**
     * \brief Stream insertion operator.
     *        Prints  a "pretty" representation of the type into the stream
     */
    friend std::ostream & operator <<(std::ostream & out, const Type * type);

    /**
     * \brief Creates a instance of the type specified.
     */
    std::shared_ptr<void> createInstance() const;

    /**
     * \brief Creates an instance of the type and casts it to T.
     */
    template<typename T> std::shared_ptr<T> createTypedInstance()const;

    virtual bool convertible(const Type * type)const{return false;}
    virtual bool serializeable(const std::string & format)const{return false;}
    virtual bool stringifiable()const{return false;}
    virtual bool constructible()const{return false;}
    


    Object * toObjectPointer(void * object);
    void objectToString(const void * object, std::ostream & stream)const;
    std::string objectToString(const void * object)const;
        

    std::function<Object*(void * )> basic_property(ConvertToObjectPointerFunction);    
    bool basic_property(IsConvertibleToObject);

    /**
     * \brief Type Id.
     *
     */
    TypeId basic_property(Id);

    /**
     * \brief true if the type is constructible
     */
    bool basic_property(IsConstructible);
    /**
     * \brief CreateInstanceFunction.
     *        may contain a function which creates an instance of the specified type
     *
     */
    std::function<std::shared_ptr<void>()> basic_property(CreateInstanceFunction);

    

    std::function<void(const void *, std::ostream &)> basic_property(ObjectToStringFunction);

    /**
     * \brief Property Name.
     *        the name of this type
     *
     */
    std::string basic_property(Name);



    /**
     * \brief The Set of Members this type can reflect over
     *
     */
    PROPERTYSET(const MemberInfo *, Members,,);
public:

    /**
     * \brief Gets the properties of this type
     */
    Set<const PropertyInfo*> Properties() const;

    /**
     * \brief Gets a member by name.
     */
    const MemberInfo * getMember(const std::string & name) const;

    /**
     * \brief Gets method information.
     */
    const MethodInfo * getMethodInfo(const std::string & name) const;

    /**
     * \brief Gets a property by name.
     *        
     */
    const PropertyInfo * getProperty(const std::string & name) const;

    /**
     * \brief returns true if other class is super class of this type.  @TODO: check if its not the other way around...
     *
     * \param other The other.
     *
     * \return  true if super class of, false if not.
     */
    bool isSuperClassOf(const Type * other) const;

protected:

    /**
     * \brief overrides Node on Predecessor added to react when the type hierarchy changes
     *
     * \param [in,out]  type  If non-null, the type.
     */
    void onPredecessorAdded(Type* type);

    /**
     * \brief overridden.  reacts to a predecessor being removed
     *
     * \param [in,out]  type  If non-null, the type.
     */
    void onPredecessorRemoved(Type* type);
  };



  
    template<typename T> std::shared_ptr<T> Type::createTypedInstance()const{
      return std::static_pointer_cast<T>(createInstance());
    }
}