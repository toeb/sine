/**
 * Copyright (C) 2013 Tobias P. Becker
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software
 * and associated documentation files (the "Software"), to deal in the Software without restriction,
 * including without limitation the  rights to use, copy, modify, merge, publish, distribute,
 * sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 */
#pragma once
#include <config.h>
#include <core/graph/Node.h>
#include <core/collection/containers/Set.h>
#include <core/Members.h>
#include <memory>
namespace nspace
{
  // forward declarations
  class MemberInfo;
  class MethodInfo;
  class PropertyInfo;
  class Type;

  /**
   * \brief Defines an alias representing identifier for a type.
   */
  typedef uint TypeId;


  /**
   * \brief Type.
   *        this class represents a Type. it Inherits from Node<Type> so that a the typehierarcy may be accessed.
   *        Alot of Macros are defined to help specify types / members for classes
   *        This class contains methods for reflecting over Objects
   */
  class Type : public Node<Type>
  {
private:

    /**
     * \brief The type counter. - every type has a unique int associated with it which is generated by incrementing this counter at every type registration
     */
    static TypeId _typeCounter;
protected:

    /**
     * \brief Default constructor.
     *        Registers a type.
     */
    Type();
public:

    /**
     * \brief Equality operator.
     *
     * \param a The first type to compare.
     * \param b The second type to compare.
     *
     * \return  true if the types are considered equivalent.
     */
    friend bool operator==(const Type & a, const Type & b);

    /**
     * \brief Inequality operator.
     *
     * \param a The first type to compare.
     * \param b The second type to compare.
     *
     * \return  true if the types are not considered equivalent.
     */
    friend inline bool operator!=(const Type & a, const Type & b) {
      return !(a==b);
    }

    /**
     * \brief Stream insertion operator.
     *        Prints  a "pretty" representation of the type into the stream
     *
     * \param [in,out]  out The outstream.
     * \param type          The type.
     *
     * \return  The shifted result.
     */
    friend std::ostream & operator <<(std::ostream & out, const Type & type);

    /**
     * \brief Stream insertion operator.
     *        Prints  a "pretty" representation of the type into the stream
     *
     * \param [in,out]  out The outstream.
     * \param type          The type.
     *
     * \return  The shifted result.
     */
    friend std::ostream & operator <<(std::ostream & out, const Type * type);

    /**
     * \brief Creates a instance of the type specified.
     *
     * \return  The new instance or zero if instanciation was not possibly.
     */
    std::shared_ptr<void> createInstance() const;

    template<typename T>
    std::shared_ptr<T> createTypedInstance()const{
      return std::static_pointer_cast<T>(createInstance());
    }
   

    void objectToString(const void * object, std::ostream & stream)const;
    std::string objectToString(const void * object)const;

    BASIC_PROPERTY(bool, IsConstructible,public,,,);

    /**
     * \brief Type Id.
     *
     */
    BASIC_PROPERTY(TypeId, Id,public,,,);

    /**
     * \brief CreateInstanceFunction.
     *        may contain a function which creates an instance of the specified type
     *
     */
    BASIC_PROPERTY(std::function<std::shared_ptr<void>()>, CreateInstanceFunction, public,,,);

    

    typedef std::function<void(const void *, std::ostream &)> ObjectToStringFunction;
    BASIC_PROPERTY(ObjectToStringFunction, ObjectToStringFunction,protected,,,);

    /**
     * \brief Property Name.
     *        the name of this type
     *
     */
    BASIC_PROPERTY(std::string,Name,public,,,);

    /**
     * \brief The Set of Members this type can reflect over
     *
     */
    PROPERTYSET(const MemberInfo *, Members,,);
public:

    /**
     * \brief Gets the properties of this type
     *
     * \return  the set of properties
     */
    Set<const PropertyInfo*> Properties() const;

    /**
     * \brief Gets a member by name.
     *
     * \param name  The name.
     *
     * \return  null if it fails, else the member.
     */
    const MemberInfo * getMember(const std::string & name) const;

    /**
     * \brief Gets method information.
     *
     * \param name  The name of the method.
     *
     * \return  null if it fails, else the method information.
     */
    const MethodInfo * getMethodInfo(const std::string & name) const;

    /**
     * \brief Gets a property by name.
     *
     * \param name  The name.
     *
     * \return  null if it fails, else the property.
     */
    const PropertyInfo * getProperty(const std::string & name) const;

    /**
     * \brief returns true if other class is super class of this type.  @TODO: check if its not the other way around...
     *
     * \param other The other.
     *
     * \return  true if super class of, false if not.
     */
    bool isSuperClassOf(const Type & other) const;

protected:

    /**
     * \brief overrides Node on Predecessor added to react when the type hierarchy changes
     *
     * \param [in,out]  type  If non-null, the type.
     */
    void onPredecessorAdded(Type* type);

    /**
     * \brief overridden.  reacts to a predecessor being removed
     *
     * \param [in,out]  type  If non-null, the type.
     */
    void onPredecessorRemoved(Type* type);
  };
}