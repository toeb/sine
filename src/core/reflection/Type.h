/**
 * Copyright (C) 2013 Tobias P. Becker
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software
 * and associated documentation files (the "Software"), to deal in the Software without restriction,
 * including without limitation the  rights to use, copy, modify, merge, publish, distribute,
 * sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 *
 */
#pragma once
#include <config.h>
#include <core/Node.h>
#include <core/collection/containers/Set.h>
#include <core/Members.h>
#include <core/patterns/Singleton.h>
#include <memory>
namespace nspace
{
  // forward declarations
  class MemberInfo;
  class MethodInfo;
  class PropertyInfo;
  class Type;

  /**
   * \brief Defines an alias representing identifier for a type.
   */
  typedef uint TypeId;

  /**
   * \brief Types. a class containing a set of all types.
   */
  class Types
  {
private:
    SINGLETON(Types) {}
    Set< const Type * > _types;
public:
    static const Set< const Type * > & allTypes();
    static const Type * getType(const std::string & name);
    static bool registerType(const Type * type);
  };

  /**
   * \brief Type.
   *        this class represents a Type. it Inherits from Node<Type> so that a the typehierarcy may be accessed.
   *        Alot of Macros are defined to help specify types / members for classes
   *        This class contains methods for reflecting over Objects
   */
  class Type : public Node<Type>
  {
private:

    /**
     * \brief The type counter. - every type has a unique int associated with it which is generated by incrementing this counter at every type registration
     */
    static TypeId _typeCounter;
protected:

    /**
     * \brief Default constructor.
     *        Registers a type.
     */
    Type();
public:

    /**
     * \brief Equality operator.
     *
     * \param a The first type to compare.
     * \param b The second type to compare.
     *
     * \return  true if the types are considered equivalent.
     */
    friend bool operator==(const Type & a, const Type & b);

    /**
     * \brief Inequality operator.
     *
     * \param a The first type to compare.
     * \param b The second type to compare.
     *
     * \return  true if the types are not considered equivalent.
     */
    friend inline bool operator!=(const Type & a, const Type & b) {
      return !(a==b);
    }

    /**
     * \brief Stream insertion operator.
     *        Prints  a "pretty" representation of the type into the stream
     *
     * \param [in,out]  out The outstream.
     * \param type          The type.
     *
     * \return  The shifted result.
     */
    friend std::ostream & operator <<(std::ostream & out, const Type & type);

    /**
     * \brief Stream insertion operator.
     *        Prints  a "pretty" representation of the type into the stream
     *
     * \param [in,out]  out The outstream.
     * \param type          The type.
     *
     * \return  The shifted result.
     */
    friend std::ostream & operator <<(std::ostream & out, const Type * type);

    /**
     * \brief Creates a instance of the type specified.
     *
     * \return  The new instance or zero if instanciation was not possibly.
     */
    void * createInstance() const;

    void deleteInstance(void * instance)const;

    /**
     * \brief Property Id.
     *
     */
    BASIC_PROPERTY(TypeId, Id,public,,,);

    /**
     * \brief Property CreateInstanceFunction.
     *        may contain a function which creates an instance of the specified type
     *
     */
    BASIC_PROPERTY(std::function<void * ()>, CreateInstanceFunction, protected,,,);

    /**
     * \brief Property DeleteInstanceFunction.
     *        may contain a function which deletes an instance of the specified type
     *
     */
    BASIC_PROPERTY(std::function< void(void*)>, DeleteInstanceFunction, protected,,,);
    
    /**
     * \brief Property Name.
     *        the name of this type
     *
     */
    BASIC_PROPERTY(std::string,Name,public,,,);

    /**
     * \brief The Set of Members this type can reflect over
     *
     */
    PROPERTYSET(const MemberInfo *, Members,,);
public:

    /**
     * \brief Gets the properties of this type
     *
     * \return  the set of properties
     */
    Set<const PropertyInfo*> Properties() const;

    /**
     * \brief Gets a member by name.
     *
     * \param name  The name.
     *
     * \return  null if it fails, else the member.
     */
    const MemberInfo * getMember(const std::string & name) const;

    /**
     * \brief Gets method information.
     *
     * \param name  The name of the method.
     *
     * \return  null if it fails, else the method information.
     */
    const MethodInfo * getMethodInfo(const std::string & name) const;

    /**
     * \brief Gets a property by name.
     *
     * \param name  The name.
     *
     * \return  null if it fails, else the property.
     */
    const PropertyInfo * getProperty(const std::string & name) const;

    /**
     * \brief returns true if other class is super class of this type.  @TODO: check if its not the other way around...
     *
     * \param other The other.
     *
     * \return  true if super class of, false if not.
     */
    bool isSuperClassOf(const Type & other) const;

protected:

    /**
     * \brief overrides Node on Predecessor added to react when the type hierarchy changes
     *
     * \param [in,out]  type  If non-null, the type.
     */
    void onPredecessorAdded(Type* type);

    /**
     * \brief overridden.  reacts to a predecessor being removed
     *
     * \param [in,out]  type  If non-null, the type.
     */
    void onPredecessorRemoved(Type* type);
  };

  template<typename T>

  /**
   * \brief Remove pointer.
   */
  class RemovePointer
  {
public:
    typedef T Type;
  };
  template<typename T>

  /**
   * \brief Remove pointer.
   *
   * \tparam  T*  Type of the t*.
   */
  class RemovePointer<T*>
  {
public:
    typedef T Type;
  };

  template<typename T>

  /**
   * \brief Is pointer.
   */
  struct IsPointer {
    bool operator()() const {
      return false;
    }
  };
  template<typename T>

  /**
   * \brief Is pointer.
   *
   * \tparam  T*  Type of the t*.
   */
  struct IsPointer<T*> {
    bool operator()() const {
      return true;
    }
  };

  template<typename T>

  /**
   * \brief Is constant.
   */
  struct IsConst {
    bool operator()() const {
      return false;
    }
  };
  template<typename T>

  /**
   * \brief Is constant.
   *
   * \tparam  const T Type of the constant.
   */
  struct IsConst<const T> {
    bool operator()() const {
      return true;
    }
  };

  template<typename T>

  /**
   * \brief Information about the type.
   */
  class TypeInfo : public Type
  {
    TEMPLATEDSINGLETON(TypeInfo, <T>) {
      setName(RemovePointer<T>::Type::getTypeName());
    }
  };

/**
 * \brief macro allows typeinfo to be declared for primitve types. or external types
 *
 * \param TYPE  The type.
 */
#define META(TYPE) \
  template<> \
  class /*nspace::*/ TypeInfo<TYPE>: public /*nspace::*/ Type { \
    TEMPLATEDSINGLETON(TypeInfo, <TYPE>){ \
      setName(# TYPE); \
    } \
  };

/**
 * \brief META which set allows instancecreation of type by default constructor
 *
 * \param TYPE  The type.
 */
#define META_DEFAULTCONSTRUCTOR(TYPE) \
  template<> \
  class /*nspace::*/ TypeInfo<TYPE>: public /*nspace::*/ Type { \
    TEMPLATEDSINGLETON(TypeInfo, <TYPE>){ \
      setCreateInstanceFunction([] (){return new TYPE; }); \
      setDeleteInstanceFunction([](void * v){delete static_cast<TYPE*>(v);});\
      setName(# TYPE); \
    } \
  };


  /**
   * \brief Information about the type. Set<T>  /specialization
   *
   * \tparam  T Generic type parameter.
   */
  template<typename T>
  class TypeInfo<Set<T> >: public Type
  {
    TEMPLATEDSINGLETON(TypeInfo, <Set<T> >) {
      setName("Set<T>");
    }
  };


  // meta information for default types
  META_DEFAULTCONSTRUCTOR(int);
  META_DEFAULTCONSTRUCTOR(double);
  META_DEFAULTCONSTRUCTOR(bool);
  META_DEFAULTCONSTRUCTOR(float);
  META_DEFAULTCONSTRUCTOR(char);
  META_DEFAULTCONSTRUCTOR(short);
  META_DEFAULTCONSTRUCTOR(unsigned int);
  META_DEFAULTCONSTRUCTOR(long);
  META_DEFAULTCONSTRUCTOR(long long);
  META_DEFAULTCONSTRUCTOR(unsigned char);

  META_DEFAULTCONSTRUCTOR(std::string);

  META(std::ostream);
  META(std::istream);
  META(std::iostream);
  META(std::ifstream);
  META(std::ofstream);

/**
 * \brief this macro returns the Type * instance for TYPENAME.
 *
 * \param TYPENAME  The typename.
 */
#define typeof(TYPENAME) nspace::TypeInfo<TYPENAME>::instance()

/**
 * \brief Macro for making an object a typed object. defines a static meta information structure
 *        (TypeData) and virtual access methods @TODO rename TYPED_OBJECT to TYPED_CLASS.
 *
 * \param TYPE  The type.
 */
#define TYPED_OBJECT(TYPE) \
private: \
  typedef TYPE CurrentClassType; \
public: \
  static std::string getTypeName(){return std::string(# TYPE); } \
  virtual inline const nspace::Type & getType() const {return *nspace::TypeInfo<TYPE>::instance(); } \
  virtual inline bool isInstanceOf(const Type * type) const { return type->isSuperClassOf(this->getType()); } \
private:

/**
 * \brief sets up inheritance hierarchy.
 *        Subclass specify SUBCLASSOF in the class declaration so that the hierarchy can be generated
 *
 * \param TYPE  The parent type.
 */
#define SUBCLASSOF(TYPE) \
private: \
  STATIC_INITIALIZER(TYPE ## Subclass,{ \
                       auto unconstCurrentType = const_cast<nspace::Type*>(dynamic_cast<const nspace::Type*>(typeof(CurrentClassType))); \
                       auto unconstSuperType = const_cast<nspace::Type*>(dynamic_cast<const nspace::Type*>(typeof(TYPE))); \
                       unconstSuperType->successors()|=unconstCurrentType; \
                     })
}
